# -*- coding: utf-8 -*-
"""Adder_cirq_qiskit.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dMzh1Nn24Aos_jXF7uCu9k3GK19wvB8d

#Instaation
"""

pip install cirq

pip install qiskit[visualization]

pip install qiskit-aer

pip install pylatexenc matplotlib

"""#Problem 2 (Cirq)"""

"""Adder"""
# Import the Cirq library
import cirq
# Get qubits
qubits = cirq.LineQubit.range(17)




def adder_2(a, b, s, c):
  yield cirq.CCNOT(a,b,s)
  yield cirq.CNOT(a,c)
  yield cirq.CNOT(b,c)

circuit = cirq.Circuit()
q0, q1, q2 = [0,0,1]


#The inputs are at qubits 15,12,4. The outputs are 0,1,3,8,14

if q2==1:
  circuit.append(cirq.X(qubits[15]))
if q1 ==1:
  circuit.append(cirq.X(qubits[12]))
if q0 ==1 :
  circuit.append(cirq.X(qubits[4]))

circuit.append(cirq.X(qubits[16]))
circuit.append(cirq.X(qubits[9]))


circuit.append(adder_2(qubits[16],qubits[15],qubits[13],qubits[14]))

circuit.append(adder_2(qubits[12],qubits[13],qubits[10],qubits[11]))
circuit.append(adder_2(qubits[11],qubits[9],qubits[7],qubits[8]))

circuit.append(adder_2(qubits[10],qubits[7],qubits[5],qubits[6]))
circuit.append(adder_2(qubits[6],qubits[4],qubits[2],qubits[3]))

circuit.append(adder_2(qubits[5],qubits[2],qubits[0],qubits[1]))

circuit.append(cirq.measure(qubits[14]))
circuit.append(cirq.measure(qubits[8]))
circuit.append(cirq.measure(qubits[3]))
circuit.append(cirq.measure(qubits[0]))
circuit.append(cirq.measure(qubits[1]))



simulator = cirq.Simulator()
result = simulator.simulate(circuit, initial_state=0)
print(f'{0,1,1}+{q0,q1,q2}=',result.measurements['q(0)'][0],result.measurements['q(1)'][0],result.measurements['q(3)'][0],result.measurements['q(8)'][0],result.measurements['q(14)'][0])

print()
print()
print('='*20)
print(circuit)

"""Adder"""
# Import the Cirq library
import cirq
# Get three qubits -- two data and one target qubit
qubits = cirq.LineQubit.range(20)

q0, q1, q2 = [0,0,1]


def adder_2(a, b, s, c):
  yield cirq.CCNOT(a,b,s)
  yield cirq.CNOT(a,c)
  yield cirq.CNOT(b,c)

def adder_1(a, b, s, c):
  yield cirq.CNOT(b,c)
  yield cirq.CNOT(a,c)
  yield cirq.CCNOT(a,b,s)

circuit = cirq.Circuit()

#The inputs are at qubits 15,12,4. The outputs are 0,1,3,8,14

if q2==1:
  circuit.append(cirq.X(qubits[15]))
if q1 ==1:
  circuit.append(cirq.X(qubits[12]))
if q0 ==1 :
  circuit.append(cirq.X(qubits[4]))

circuit.append(cirq.X(qubits[16]))
circuit.append(cirq.X(qubits[9]))

def V():
  circuit.append(adder_2(qubits[16],qubits[15],qubits[13],qubits[14]))

  circuit.append(adder_2(qubits[12],qubits[13],qubits[10],qubits[11]))
  circuit.append(adder_2(qubits[11],qubits[9],qubits[7],qubits[8]))

  circuit.append(adder_2(qubits[10],qubits[7],qubits[5],qubits[6]))
  circuit.append(adder_2(qubits[6],qubits[4],qubits[2],qubits[3]))

  circuit.append(adder_2(qubits[5],qubits[2],qubits[0],qubits[1]))

def Cm():
  circuit.append(cirq.CNOT(qubits[14],qubits[17]))
  circuit.append(cirq.CNOT(qubits[8],qubits[18]))
  circuit.append(cirq.CNOT(qubits[3],qubits[19]))

def Vdag():
  circuit.append(adder_1(qubits[5],qubits[2],qubits[0],qubits[1]))
  circuit.append(adder_1(qubits[6],qubits[4],qubits[2],qubits[3]))
  circuit.append(adder_1(qubits[10],qubits[7],qubits[5],qubits[6]))
  circuit.append(adder_1(qubits[11],qubits[9],qubits[7],qubits[8]))
  circuit.append(adder_1(qubits[12],qubits[13],qubits[10],qubits[11]))
  circuit.append(adder_1(qubits[16],qubits[15],qubits[13],qubits[14]))

V()
Cm()
Vdag()

'''
circuit.append(cirq.measure(qubits[14]))
circuit.append(cirq.measure(qubits[8]))
circuit.append(cirq.measure(qubits[3]))
circuit.append(cirq.measure(qubits[0]))
circuit.append(cirq.measure(qubits[1]))
'''
circuit.append(cirq.measure(qubits[17]))
circuit.append(cirq.measure(qubits[18]))
circuit.append(cirq.measure(qubits[19]))

simulator = cirq.Simulator()
result = simulator.simulate(circuit, initial_state=0)
print('='*40)
print()
print()

print(f'{0}{1}{1} + {q0}{q1}{q2} (mod 8) =',result.measurements['q(19)'][0],result.measurements['q(18)'][0],result.measurements['q(17)'][0])

print()
print()
print('='*40)
print(circuit)

"""#Problem 2 (Qiskit)"""

from qiskit import QuantumCircuit, Aer, execute

qc = QuantumCircuit(17,5)

def adder_2(a, b, s, c):
    """Constructs a quantum circuit for a 2-qubit adder."""
    qc.ccx(a, b, s)
    qc.cx(a, c)
    qc.cx(b, c)





q0, q1, q2 = [0,0,0]

if q2==1:
  qc.x(15)
if q1 ==1:
  qc.x(12)
if q0 ==1 :
  qc.x(4)

qc.x(16)
qc.x(9)
qc.barrier()
adder_2(16, 15, 13, 14)
adder_2(12, 13, 10, 11)
adder_2(11,9,7,8)
adder_2(10,7,5,6)
adder_2(6,4,2,3)
adder_2(5,2,0,1)
qc.barrier()


qc.measure(14,0)
qc.measure(8,1)
qc.measure(3,2)
qc.measure(1,4)
qc.measure(0,3)


qc.draw('mpl')

# Choose the Aer simulator backend
backend = Aer.get_backend('qasm_simulator')

# Execute the circuit on the backend
job = execute(qc, backend, shots=1000)

# Get the result
result = job.result()

# Get the counts
counts = result.get_counts(qc)

# Print the counts
sum = next((key for key, value in counts.items() if value == 1000), None)
print("="*20)
print(f'{0,1,1} + {q0,q1,q2} mod8 =',sum[2:5])
print("="*20)

from qiskit import QuantumCircuit, Aer, execute

qc = QuantumCircuit(20,3)

def adder_2(a, b, s, c):
    """Constructs a quantum circuit for a 2-qubit adder."""
    qc.ccx(a, b, s)
    qc.cx(a, c)
    qc.cx(b, c)

def adder_1(a, b, s, c):
    qc.cx(b, c)
    qc.cx(a, c)
    qc.ccx(a, b, s)

q0, q1, q2 = [0,0,1]

if q2==1:
  qc.x(15)
if q1 ==1:
  qc.x(12)
if q0 ==1 :
  qc.x(4)

qc.x(16)
qc.x(9)
qc.barrier()

adder_2(16, 15, 13, 14)
adder_2(12, 13, 10, 11)
adder_2(11,9,7,8)
adder_2(10,7,5,6)
adder_2(6,4,2,3)
adder_2(5,2,0,1)
qc.barrier()


qc.cx(14,17)
qc.cx(8,18)
qc.cx(3,19)
qc.barrier()

adder_1(5,2,0,1)
adder_1(6,4,2,3)
adder_1(10,7,5,6)
adder_1(11,9,7,8)
adder_1(12, 13, 10, 11)
adder_1(16, 15, 13, 14)
qc.barrier()

qc.measure(17,0)
qc.measure(18,1)
qc.measure(19,2)

qc.draw('mpl')

# Choose the Aer simulator backend
backend = Aer.get_backend('qasm_simulator')

# Execute the circuit on the backend
job = execute(qc, backend, shots=1000)

# Get the result
result = job.result()

# Get the counts
counts = result.get_counts(qc)

# Print the counts
sum = next((key for key, value in counts.items() if value == 1000), None)
print("="*40)
print(f'{0}{1}{1} + {q0}{q1}{q2} mod8 =',sum)
print("="*40)

"""#Problem 3"""

import cirq


def CSWAP(x0, x1, x2):
  q0, q1, q2 =cirq.LineQubit.range(3)

  qc = cirq.Circuit()

  if x2==1:
    qc.append(cirq.X(q2))
  if x1 ==1:
    qc.append(cirq.X(q1))
  if x0 ==1 :
    qc.append(cirq.X(q0))


  qc.append([cirq.CCNOT(q0,q1,q2), cirq.CCNOT(q0,q2,q1),cirq.CCNOT(q0,q1,q2)])

  qc.append(cirq.measure(q0))
  qc.append(cirq.measure(q1))
  qc.append(cirq.measure(q2))


  simulator = cirq.Simulator()
  result = simulator.simulate(qc, initial_state=0)
  print('='*40)
  print()
  print()

  print(f'{x0} {x1} {x2} --->',result.measurements['q(0)'][0],result.measurements['q(1)'][0],result.measurements['q(2)'][0])

  print()
  print()
  print('='*40)

print("checking possible inputs and outputs: ")
for x0 in range(2):
  for x1 in range(2):
    for x2 in range(2):
      CSWAP(x0, x1, x2)

